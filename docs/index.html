<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
        <meta name="description" content="" />
        <meta name="author" content="" />
        <title>Small Business - Fast Robot  Yiqi Sun</title>
        <!-- Favicon-->
        <link rel="icon" type="image/x-icon" href="assets/favicon.ico" />
        <!-- Core theme CSS (includes Bootstrap)-->
        <link href="css/styles.css" rel="stylesheet" />
    </head>
    <body>
        <!-- Responsive navbar-->
        <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
            <div class="container px-5">
                <a class="navbar-brand" href="#!">Start Bootstrap</a>
                <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button>
                <div class="collapse navbar-collapse" id="navbarSupportedContent">
                    <ul class="navbar-nav ms-auto mb-2 mb-lg-0">
                        <li class="nav-item"><a class="nav-link active" aria-current="page" href="#!">Home</a></li>
                        <li class="nav-item"><a class="nav-link" href="#!">About</a></li>
                        <li class="nav-item"><a class="nav-link" href="#!">Contact</a></li>
                        <li class="nav-item"><a class="nav-link" href="#!">Services</a></li>
                    </ul>
                </div>
            </div>
        </nav>
        <!-- Page Content-->
        <div class="container px-4 px-lg-5">
            <!-- Heading Row-->
            <div class="row gx-4 gx-lg-5 align-items-center my-5">
                <div class="col-lg-7"><img class="img-fluid rounded mb-4 mb-lg-0" src="https://dummyimage.com/900x400/dee2e6/6c757d.jpg" alt="..." /></div>
                <div class="col-lg-5">
                    <h1 class="font-weight-light">Fast Robot Lab Page</h1>
                    <p>This is a template for Fast robot</p>
                    <a class="btn btn-primary" href="#!">Call to Action!</a>
                </div>
            </div>
            <!-- Call to Action-->
            <div class="card text-white bg-secondary my-5 py-4 text-center">
                <div class="card-body"><p class="text-white m-0">This call to action card is a great place to showcase some important information or display a clever tagline!</p></div>
            </div>






            
            <!-- Content Row-->
            <div class="row gx-4 gx-lg-5">
                <div class="col-md-4 mb-5">
                    <div class="card h-100">
                        <div class="card-body">
                            <h2 class="card-title">Lab One</h2>
                            <p class="card-text">Lab 1: The Artemis board and Bluetooth. <br> In the first experiment, I set up a basic environment for subsequent experiments and used examples to test the environment. In addition, I also used BLE to establish Bluetooth communication between the Artemis board and the computer, and wrote multiple examples to test the transmission and reception of data in different ways.</p>
                        </div>
                        <button type="button" class="btn btn-primary btn-sm" data-bs-toggle="modal" data-bs-target="#labOneModal">
        More Info
    </button>
                    </div>
                <div class="modal fade" id="labOneModal" tabindex="-1" aria-labelledby="labOneModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="labOneModalLabel">Lab One Information</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
<div class="modal-body" style="overflow-y: auto; max-height: 80vh;">


                    <h2>Setting Up Computer for Python Development with the Artemis Board</h2>
    <ol>
        <li><strong>Ensure Python 3.9+ and pip 21.0+</strong> are installed. Check versions with <code>python3 --version</code> and <code>pip --version</code>.</li>
        <li><strong>Install Python and pip</strong> using my system's package manager for Linux/FreeBSD users.</li>
        <li><strong>Create a virtual environment</strong> named "FastRobots_ble" in my project directory using <code>python3 -m venv FastRobots_ble</code>.</li>
        <li><strong>Activate the virtual environment</strong> with <code>.\FastRobots_ble\Scripts\activate</code> (Windows) or its Linux/macOS equivalent.</li>
        <li><strong>Install necessary Python packages</strong> (<code>numpy</code>, <code>pyyaml</code>, <code>colorama</code>, <code>nest_asyncio</code>, <code>bleak</code>, <code>jupyterlab</code>) using pip within the virtual environment.</li>
        <li><strong>Set up the Lab 2 codebase</strong> by downloading, unzipping, and ensuring the <code>ble_python</code> directory is in my project directory.</li>
        <li><strong>Start the Jupyter server</strong> with <code>jupyter lab</code> to work on Python code in Jupyter notebooks.</li>
    </ol>
    <p>This streamlined process prepares my computer for developing Bluetooth communication projects with the Artemis board using Python.</p>
                <h2>Prelab 1 Blink test</h2>
            <p> In the first lab I ran the blink example and got the following results</p>
                <video src="images/lab1/blink.mp4" controls width="300"> </video>
                <h2 class="card-title"> Prelab 2 Serial test</h2>
                    <p>The prelab 2 is to run an Artemis example sketch that operates serial communication between the board and PC.</p>
<p>The MCU contains two UART peripherals to perform serial communication. In this sketch, the baud rate is set to be 115200. Upon running the program, the MCU counts from 0 to 9 then enters a loop where it listens and echoes messages received. The result is shown as follows.</p>
                <img src="images/lab1/serial.png" controls width="750"  >
                    <h2>Prelab 3 Analog read test</h2>
            <p> The prelab 3 is to run another Artemis example analogRead to test the temperature sensor of the MCU.</p>
<p>Upon running the example program, the MCU continuously reads data from the temperature sensor and prints the information to the serial monitor. The result shows as the demo video.</p>
                <video src="images/lab1/analog.mp4" controls width="300" > </video>
                    <h2>Prelab 4 Microphone test</h2>
            <p> In this task, an example sketch is run to test the onboard pulse density microphone (PDM). The one with the largest magnitude among the sensed frequencies is printed to the serial monitor.</p>
<p>In the demo video below, I tried to sing. The resultant data range was 100-400, indicating higher frequencies.</p>
                <video src="images/lab1/Mic.mp4"  controls width="300"> </video>
                    <h2>Prelab Additiional for 5000-level</h2>
            <p> An extra assignment involves creating a detector for the musical note "A."</p>
                <img src="images/lab1/A.png" controls width="750" > </img>
                <video src="images/lab1/A.mp4" controls width="300" > </video>
<h2>Artemis Board Setup Summary</h2>
    <ol>
        <li><strong>Obtain Artemis MAC Address:</strong> Get the BLE MAC address from the Artemis board.</li>
        <img src="images/lab1/macaddress.png" controls width="750">
        <li><strong>Update <code>connections.yaml</code>:</strong> Replace <code>artemis_address</code> with the obtained MAC address.</li>
        <li><strong>Generate UUID:</strong> Use a Python script with <code>from uuid import uuid4; print(uuid4())</code> to generate a UUID.</li>
        <li><strong>Update Files with UUID:</strong>
            <ul>
                <li>For <code>ble_arduino.ino</code>: Replace the BLEService UUID.</li>
                <li>For <code>connections.yaml</code>: Update <code>ble_service</code> with the new UUID.</li>
            </ul>
        </li>
        <li><strong>Save Changes:</strong> Ensure all files are saved with updates.</li>
        <li><strong>Test BLE Connection:</strong> Re-test to confirm everything is set up correctly.</li>
    </ol>
    <p>Note: Adjust <code>base_ble.py</code> for platform-specific configurations if necessary.</p>
                <h2 class="card-title">Task 1: ECHO</h2>
                <p class="card-text">
Issue an ECHO command to transmit a specific string from the computer to the Artemis board. For instance, when the computer dispatches the string "1" utilizing the ECHO functionality, it should anticipate receiving a modified version of the string, such as "Robot says -> 1 :)", retrieved through a GATT characteristic read operation.</p>
                <img src="images/lab1/ECHO.png" controls width="750">
                <p class="card-text">
                    The picture below is the result returned on the Serial Monitor after Artemis accepts the ECHO command.</p>
                 <img src="images/lab1/ECHO1.png" controls width="750">
     <h2 class="card-title">Task 2： GET_TIME</h2>
                <p class="card-text">
The second task is to complete a command GET_TIME_MILLIS where the MCU sends the time in the format of "T:123456".</p>
<p class="card-text">I added GET_TIME_MILLIS to the enumeration of both PC and Artemis program. I completed the command as:</p>
                <img src="images/lab1/gettimecode.png" controls width="750">
    <p class="card-text">The result shows as:</p>
                <img src="images/lab1/gettime.png" controls width="750">

     <h2 class="card-title">Task 3： Handler</h2>
                <p class="card-text">
The second task is to complete a command GET_TIME_MILLIS where the MCU sends the time in the format of "T:123456".</p>
<p class="card-text">I added GET_TIME_MILLIS to the enumeration of both PC and Artemis program. I completed the command as:</p>
                <img src="images/lab1/handler.png" controls width="750">

    <h2 class="card-title">Task 4： Loop_send</h2>
                <p class="card-text">
The second task is to complete a command GET_TIME_MILLIS where the MCU sends the time in the format of "T:123456".</p>
<p class="card-text">I added GET_TIME_MILLIS to the enumeration of both PC and Artemis program. I completed the command as:</p>
                <img src="images/lab1/sendloopcode.png" controls width="750">
    <p class="card-text">The result shows as:</p>
                <img src="images/lab1/sendloop.png" controls width="750">

    <h2 class="card-title">Task 5： Send Time Data</h2>
                <p class="card-text">
The second task is to complete a command GET_TIME_MILLIS where the MCU sends the time in the format of "T:123456".</p>
<p class="card-text">I added GET_TIME_MILLIS to the enumeration of both PC and Artemis program. I completed the command as:</p>
                <img src="images/lab1/sendtimecode.png" controls width="750">
    <p class="card-text">The result shows as:</p>
                <img src="images/lab1/sendtime.png" controls width="750">

     <h2 class="card-title">Task 6： Send Temp Data</h2>
                <p class="card-text">
The second task is to complete a command GET_TIME_MILLIS where the MCU sends the time in the format of "T:123456".</p>
<p class="card-text">I added GET_TIME_MILLIS to the enumeration of both PC and Artemis program. I completed the command as:</p>
                <img src="images/lab1/sendtempcode.png" controls width="750">
    <p class="card-text">The result shows as:</p>
                <img src="images/lab1/sendtemp.png" controls width="750">

    <h2 class="card-title">Task 7： Limitations</h2>
                <p class="card-text">
The Artemis board is equipped with 384 kB of RAM, and assuming this entire memory capacity is available for storing sampled data, it's possible to calculate the storage capacity for 16-bit data samples. By converting the board's RAM size into bits (384 * 1000 * 8) and then dividing by 16 bits (the size of each data sample), we find that a total of 192,000 16-bit samples can be accommodated. If these samples are collected at a rate of 150 Hz, the board can record data continuously for 1280 seconds before its memory is full, as 192,000 samples divided by 150 samples per second equals 1280 seconds. Consequently, this means the board can handle 256 "5-second flows," where each flow consists of 16-bit values sampled at 150 Hz. "T:123456".</p>

     <h2 class="card-title">5000-level 1 ： Data Rate</h2>
                <p class="card-text">
In order to generate messages of various lengths, I implemented a DATARATE command that prompts the MCU to dispatch a string of a specific length as determined by the PC. For instance, when the PC executes the command ble.send_command(CMD.DATARATE, 20), the MCU responds by sending back a string composed of 20 period characters ('.'), constituting a total of 20 bytes.
</p>

                <img src="images/lab1/dataratecode.png" controls width="750">
    <p class="card-text">To track the data rate in real-time, I configured a notification handler on the PC that captures the current time recv_time each time a message is received. Following this, the PC commands the Artemis board to transmit a reply that includes an extra byte. The time of dispatch send_time is noted, and the data rate is determined by dividing the message length by the time interval (recv_time - send_time), with this process repeating for each message exchange.
</p>
                <img src="images/lab1/dataratepy.png" controls width="750">
    <p class="card-text">The plot shows as:</p>
               <img src="images/lab1/datarate.png" controls width="750">
    <p class="card-text">
The graph suggests that there is a general trend where the data rate rises with the increase in message payload size. Consequently, we can infer that larger message sizes contribute to minimizing overhead proportionally and enhance the actual data transfer rate. Conversely, transmitting data in several smaller packets incurs more overhead.</p>

     <h2 class="card-title">5000-level 2 ： Reliability</h2>
                <p class="card-text">
To tally the quantity of messages dispatched and acknowledged by each party, I executed a command on the Artemis board that persistently sends messages, each tagged with a sequential index. Concurrently, the PC maintains a count of the messages it receives through a dedicated handler:</p>

                <img src="images/lab1/reliabilitycode.png" controls width="750">
                <img src="images/lab1/reliability.png" controls width="750">
    <p class="card-text">With the MCU transmitting data incessantly, it achieves the maximal possible data rate. During the examination, the computer successfully captured every message emanating from Artemis, with no data loss occurring. From this observation, it's reasonable to deduce that the communication channel is dependable.</p>
            
</div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">close</button>
            </div>
        </div>
    </div>
</div>
                </div>






    



 <!-- Content Row-->
            <div class="row gx-4 gx-lg-5">
                <div class="col-md-4 mb-5">
                    <div class="card h-100">
                        <div class="card-body">
                            <h2 class="card-title">Lab Two</h2>
                            <p class="card-text">Lab two is about IMU model and the filters applied for the data.</p>
                        </div>
                        <button type="button" class="btn btn-primary btn-sm" data-bs-toggle="modal" data-bs-target="#labTwoModal">
        More Info
    </button>
                    </div>
                <div class="modal fade" id="labTwoModal" tabindex="-1" aria-labelledby="labTwoModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="labTwoModalLabel">Lab Two Information</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
<div class="modal-body" style="overflow-y: auto; max-height: 80vh;">


                    
 <h2 class="card-title">Task 1: IMU Setup</h2>
                <p class="card-text">
The IMU is interfaced with the Artemis microcontroller via the Qwiic breakout board. Once the IMU example code is uploaded to the Artemis, it retrieves and prints the readings from the accelerometer, gyroscope, and magnetometer sensors.</p>
                <video src="images/lab2/IMU.mp4"  controls width="300"> </video>
    <p class="card-text">In the example code, a constant AD0_VAL is defined for .begin(WIRE_PORT, AD0_VAL);. It should be set to 1, which is the default value for the SparkFun 9DoF IMU breakout, but should be 0 if the ADR jumper is closed.</p>
                <img src="images/lab2/chuizhi.png" controls width="750">
    <p class="card-text">I added codes to blink the LED on Artemis when IMU is connected and started as a visual indication:</p>
    <img src="images/lab2/blink.png" controls width="750">\



    <h2 class="card-title">Task 2: Accelerometer</h2>
    <h2 class="card-title">(a) Pitch and Roll</h2>
                <p class="card-text">
Accelerometer readings can be turned into pitch and roll through mathematical calculations. Pitch is given by pitch_a = atan2(myICM.accX(),myICM.accZ())*180/M_PI, and roll is given by roll_a = atan2(myICM.accY(),myICM.accZ())*180/M_PI.</p>
<img src="images/lab2/pitchcode.png" controls width="750">
    <p class="card-text">
Example outputs for {-90, 0, 90} degrees pitch and roll are:</p>
                <img src="images/lab2/pitch.png" controls width="750">
  <h2 class="card-title">(b) Accuracy Discussion</h2>
    <p class="card-text">
While noise significantly impacts the precision of accelerometer readings, resulting in an error of around ±2 degrees, the accuracy remains relatively high, with readings typically centered around the true values. Consequently, I believe that a two-point calibration is unnecessary in this scenario.</p>

<h2 class="card-title">(c) Frequency Spectrum Analysis</h2>
    <p class="card-text">
FFT is used to analyze noise in accelerometer readings. I sampled roll data with a sample rate of 64 for 5 seconds and got 320 points to perform FFT. During the sampling period, I slowly turned IMU around its x-axis.</p>
     <img src="images/lab2/fftcode.png" controls width="750">
     <img src="images/lab2/fft.png" controls width="750">
    <p class="card-text">
        With the sampled data from Artemis, a python script was run to generate FFT result:</p>
    <img src="images/lab2/fftcode1.png" controls width="750">
    <img src="images/lab2/f.png" controls width="750">
  <p class="card-text">  
The frequency domain plot reveals that the primary component, representing the pertinent data, is situated in the low-frequency region near 0 Hz. Notably, there are no significant spikes evident in the frequency domain plot, likely due to the default selection of a low-pass filter for the accelerometer in the IMU chip. However, if I were to opt for another cut-off frequency to further attenuate residual noise, I would select 5 Hz. This choice would retain essential low-frequency data while effectively filtering out the majority of the noise.</p>



    <h2 class="card-title">Task 3: Gyroscope</h2>
    <h2 class="card-title">(a) Pitch, Roll, and Yaw</h2>
<p class="card-text">
    Gyroscope data are collected to calculate pitch, roll and yaw:</p>
<img src="images/lab2/gycode.png" controls width="750">
    <p class="card-text">
   Below are some example outputs at different gestures:</p>
    <img src="images/lab2/gy1.png" controls width="750">
    <img src="images/lab2/gy2.png" controls width="750">

    <h2 class="card-title">(b) Complementary Filter</h2>
    <p class="card-text">
The accelerometer, being sensitive to noise but resistant to drifting, complements the gyroscope, which produces smooth but drifting results. By combining the two sensors with a complementary filter, their respective drawbacks can be mitigated. The filter equation is represented as: theta = (theta + gyr_data * dt) * (1 - alpha) + acc_data * alpha.</p>
    <img src="images/lab2/gycode1.png" controls width="750">
    <p class="card-text">
        After several tests, I chose alpha to be 0.3 to maximize performance. Here's the video demonstrating results from accelerometer only, gyroscope only, and combined, which is close to the accurate accelerometer result but without noise:</p>
    <img src="images/lab2/gyb.png" controls width="750">


    <h2 class="card-title">Task 4: Sample Data</h2>
    <p class="card-text">
To transmit IMU data to a PC, I introduced a new command called GET_SAMPLE_IMU. This command collects IMU data into arrays, then transmits the data to the PC via Bluetooth. The data is formatted as follows: time|accx,accy,accz|gyrx,gyry,gyrz.</p>
    <img src="images/lab2/samplecode.png" controls width="750">
<p class="card-text">
    Received data are processed by a notification handler in Python and then plotted:</p>
    <img src="images/lab2/samplepy.png" controls width="750">
    <img src="images/lab2/sample.png" controls width="750">

    <p class="card-text">
Considering that an integer occupies 2 bytes and a float occupies 4 bytes, each sample will require 3 integers (6 bytes) and 6 floats (24 bytes), totaling 30 bytes. With a sampling rate of 10 samples per second, each second will generate 300 bytes of data. With 384 kB of RAM available on the Artemis, it can support approximately 1310 seconds of continuous sampling when the entire memory is allocated to the arrays.</p>


    <h2 class="card-title">Task 5: Record a Stunt</h2>
<p class="card-text">
    With the remote control, I managed to make the RC car perform stunts like flipping and spinning in place. To do a flip, the motors should first dash in one direction then motors abruptly inverse direction.</p>
<video src="images/lab2/Robot.mp4"  controls width="300"> </video>

</div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">close</button>
            </div>
        </div>
    </div>
</div>
                </div>










                <!-- Content Row-->
            <div class="row gx-4 gx-lg-5">
                <div class="col-md-4 mb-5">
                    <div class="card h-100">
                        <div class="card-body">
                            <h2 class="card-title">Lab Three</h2>
                            <p class="card-text">Lab two is about arming the Artemis board with two time-of-flight distance sensors. The range, accuracy, repeatability, and reading time of the sensors are tested.</p>
                        </div>
                        <button type="button" class="btn btn-primary btn-sm" data-bs-toggle="modal" data-bs-target="#labThreeModal">
        More Info
    </button>
                    </div>
                <div class="modal fade" id="labThreeModal" tabindex="-1" aria-labelledby="labThreeModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="labThreeModalLabel">Lab Three Information</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
<div class="modal-body" style="overflow-y: auto; max-height: 80vh;">


                    <h2>Prelab</h2>
                    <h2>(a)I2C</h2>
    <p class="card-text">
        The sensors use I2C to communicate with the Artemis board. As is specified on VL53L1X's datasheet, the default I2C address is 0x52.</p>
    <h2>(b)2 Sensors</h2>
     <p class="card-text">
         When using multiple sensors with the same default I2C address on a single I2C bus, you need to change the address of at least one of the sensors to avoid conflicts. Here's a description of how you can achieve this using a microcontroller like the SparkFun Artemis, which has programmable GPIO pins:Initially, both Time-of-Flight (ToF) sensors are connected to the Artemis, sharing the same I2C address. To differentiate them, the XSHUT (shutdown) pin of one sensor is connected to a GPIO pin on the Artemis.</p>
    <h2>(c) Placement on Robot</h2>
<p class="card-text">
Each sensor is able to detect obstacles on its corresponding side. If they detect an obstacle of the same distance simultaneously, it is probable that there is an obstacle in the front. However, this requires both of the sensors function correctly with high precision. Also, small obstacles in the front could be missed if it is closer to one sensor. More accurate measurement could be achieved by adding more sensors.</p>
  <h2>(d) Wiring</h2>
    <img src="images/lab3/wire.png" controls width="750">
    <p class="card-text">
    Qwiic cables are arranged inConsidering the robot's operational needs in diverse environments, robustness to ambient light is essential. Additionally, for a compact vehicle, a range of 1.3 meters is sufficient. Therefore, Short mode appears to be the most suitable for this application.
<h2>Lab Tasks & Results</h2>
    <h2>Task 1: Connection</h2>
     <p class="card-text">
The two ToF sensors are connected to a QWIIC break-out board then to the Artemis board.</p>
    <img src="images/lab3/connect.png" controls width="750">
     <p class="card-text">
    Upon establishing a physical connection and conducting an I2C scan, the Artemis detected a device at address 0x29. This address differs from the expected 0x52 listed in the VL53L1X datasheet. The discrepancy is due to the I2C protocol transmitting the most significant bit (MSB) first. The binary representation of 0x29 is '101001', and for 0x52 it is '1010010'. The first seven bits are identical for both values. I2C addresses are 7 bits long, so during transmission, these seven bits are sent, followed by a zero bit to complete the byte, translating 0x29 into 0x52 in an 8-bit context.</p>
     <img src="images/lab3/052.png" controls width="750">
    <h2>Task 2: Sensor Data of Chosen Mode</h2>
    <p class="card-text">
The ToF sensor operates in three distinct modes. Long mode, the default setting, allows for measurements up to 4 meters, offering the greatest range but with heightened sensitivity to variations in ambient light. Short mode limits the detection distance to 1.3 meters, yet it provides the strongest resilience to ambient light fluctuations. Medium mode presents a balance, detecting obstacles up to 3 meters while offering moderate ambient light sensitivity.</p>
    <p class="card-text">
        Considering the robot's operational needs in diverse environments, robustness to ambient light is essential. Additionally, for a compact vehicle, a range of 1.3 meters is sufficient. Therefore, Short mode appears to be the most suitable for this application.</p>
        <img src="images/lab3/sensor.png" controls width="750">
    <h2>Task 3: Two sensor working in parallel</h2>
    <p class="card-text">
During the preliminary lab session, I altered the I2C address of one sensor to 0x33 to enable simultaneous distance measurements from both sensors. The code used to modify the address is provided below:</p>
    <img src="images/lab3/code3.png" controls width="750">
    <p class="card-text">
    The result of running the measure distance with two sensor shown in the image below:</p>
    <img src="images/lab3/3.png" controls width="750">
    <h2>Task 4: ToF Sensor Speed</h2>
    <p class="card-text">
    In order to enhance the readout velocity, I eliminated the stopRanging() and clearInterrupt() instructions and relocated the startRanging() method to the setup section of the code. Now, sensor readings are outputted exclusively when new data is available, which is when .checkForDataReady() evaluates to True.</p>
    <img src="images/lab3/code4.png" controls width="750">
    <img src="images/lab3/4.png" controls width="750">
    <p class="card-text">
    Despite the presence of redundant code segments (e.g., time retrieval and serial printing), the loop consistently executes within the range of 10 to 11 milliseconds. This marks a significant reduction from the original ranging time of 50 milliseconds. Within this 10-11 millisecond window, the predominant portion of time is still consumed by the ToF (Time-of-Flight) reading operations, accounting for approximately 8 milliseconds. As a result, it is evident that the primary bottleneck in reducing processing time lies in the I2C communication conducted between the sensors and the Artemis microcontroller.</p>
    <h2>Task 5: Time v Distance</h2>
    <p class="card-text">
    A GET_ToF_10s command is written to send ToF data sampled in 5 s to PC through BLE:</p>
    <img src="images/lab3/code5.png" controls width="750">
    <p class="card-text">
The PC utilizes a notification handler to interpret the received message. Subsequently, the data samples from the two sensors are graphed against their respective time stamps.</p>
    <img src="images/lab3/python5.png" controls width="750">
    <img src="images/lab3/5.png" controls width="750">

    <h2>Task 6: (5160) Discussion on infrared transmission based sensors</h2>
    <p>The sensor utilized in this laboratory relies on time-of-flight (ToF) infrared transmission. ToF infrared sensors function by emitting a pulse-modulated signal, measuring the time taken (t) for the signal to travel to the target and return, and then calculating the distance (d) using the formula d = t * c / 2, where c represents the speed of light.ToF IR sensors offer several advantages, including a high sample rate, compact form factor, and immunity to variations in colors, textures, and ambient lighting conditions. However, they also have drawbacks such as high cost and complex processing requirements.</p>
<br>
<p>Certain infrared distance sensors utilize amplitude-based measurement methods, where the amplitude of the reflected wave is compared to that of the original emitted wave to calculate distance. These sensors offer advantages such as low cost and straightforward circuitry, and they generally perform adequately across various conditions. However, they exhibit high sensitivity to target reflectivity and may experience diminished performance in environments with high ambient light levels.</p>
    <br>
    <p>Triangulation-based sensors emit a wave at an angle towards the target and measure the reflected wave using an array of diodes. Distance calculation involves analyzing the angle of incidence and the distance between the diode with the highest signal magnitude. These sensors offer advantages such as simple circuitry and reduced sensitivity to factors like color, texture, and ambient light. However, they tend to be expensive and bulky, and may not function well in environments with high ambient light levels. Additionally, they often suffer from a low sample rate.</p>

    <h2>Task 7: (5160) Sensitivity of sensors to colors and textures</h2>
    <p class="card-text">
    In this part, I used cardboard of different colors to stick on the wall for testing to explore the impact of color on the sensor. I tested black, white and yellow respectively, and the relevant results are shown below.</p>
 <br>
    <img src="images/lab3/71.png" controls width="750">
     <br>
    <img src="images/lab3/72.png" controls width="750">
     <br>
    <img src="images/lab3/73.png" controls width="750">
<p class="card-text">
    It turned out that there was no notable difference among these materials in terms of reading accuracy and speed. Therefore, the conclusion that the ToF IR sensor is not sensitive to colors and textures is implied.</p>

</div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">close</button>
            </div>
        </div>
    </div>
</div>
                </div>









                <!-- Content Row-->
            <div class="row gx-4 gx-lg-5">
                <div class="col-md-4 mb-5">
                    <div class="card h-100">
                        <div class="card-body">
                            <h2 class="card-title">Lab Four</h2>
                            <p class="card-text">In this laboratory session, two motor drivers are initially examined for functionality before being employed to operate the vehicle's motors. Finally, an open-loop control is executed without any physical connection to the system, allowing for autonomous operation.</p>
                        </div>
                        <button type="button" class="btn btn-primary btn-sm" data-bs-toggle="modal" data-bs-target="#labFourModal">
        More Info
    </button>
                    </div>
                <div class="modal fade" id="labFourModal" tabindex="-1" aria-labelledby="labFourModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="labFourModalLabel">Lab Four Information</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
<div class="modal-body" style="overflow-y: auto; max-height: 80vh;">


                    <h2>Prelab</h2>
    <p class="card-text">
        The intended connections between the motor drivers, Artemis, and battery are shown as:</p>
    <img src="images/lab4/diagram.png" controls width="750">
      <p class="card-text">
          I chose 11, 12, 6 and 7 on Artemis as the motor drivers' input because these pins support PWM, which are implied in the schematic plot by a ~ sign.</p>
    <img src="images/lab4/artemis.png" controls width="750">
    <p class="card-text">
Separate batteries are used to energize the Artemis and the motor drivers, enabling independent troubleshooting and preventing electrical noise from the motors from affecting the Artemis. Moreover, since the motors consume energy at a much higher rate compared to the Artemis, they require an independent power source to ensure the microcontroller unit (MCU) operates efficiently without rapid power depletion.</p>
    <h2>Lab Tasks</h2>
     <h2>Task 1: PWM Signals Generation</h2>
     <p class="card-text">
    To visualize the PWM signal, the probe tip of the oscilloscope is connected to the output of a motor driver, while the ground clip is secured to the motor driver's ground terminal.</p>
   <p class="card-text">
    As for power supply of the driver, I simply attach the 3.7 V power supply to it, which is within the operating voltage range of 2.7 V to 10.8 V stated in the motor driver's datasheet.</p>
<p class="card-text">
I first tested the driver with analogWrite(11,63); analogWrite(12,0);, which generates a 25% duty cycle PWM signal as 63 is approximately 25% of 255. The corresponding oscilloscope display is:</p>
    <img src="images/lab4/25.png" controls width="750">
    <p class="card-text">
    Then I tested on analogWrite(11,127); analogWrite(12,0);, which generates a 50% duty cycle PWM signal as 127 is approximately half of 255. The corresponding oscilloscope display is:</p>
    <img src="images/lab4/50.png" controls width="750">

    <h2>Task 2: Wheels Spinning</h2>
 <p class="card-text">
    By running the following codes, I managed to spin the right-side wheels forward.</p>
    <img src="images/lab4/right.png" controls width="750">
    <video src="images/lab4/2.mp4" controls width="300" > </video>
 <p class="card-text">
    With battery attached to the motor drivers, I put the car on the Large electrical tape and let wheels on both sides spin：</p>
    <video src="images/lab4/4.mp4" controls width="300" > </video>

    <h2>Task 3: Secure Components</h2>
    <p class="card-text">
        All the components are secured as follows:</p>
    <img src="images/lab4/car.png" controls width="750">

    <h2>Task 4: Lower Limit PWM Value</h2>
    <p class="card-text">
The minimum PWM values required to propel the car forward on the laboratory floor and to execute turns are determined by programming various speed values into the Artemis and observing which values are effective in achieving movement.</p>
    <p class="card-text">
To make the car run, the lower limit PWM value I obtained is 60:</p>
    <video src="images/lab4/low.mp4" controls width="300" > </video>
    <p class="card-text">
The lower limit to do in-place turns I obtained is 110:</p>
    <video src="images/lab4/spin.mp4" controls width="300" > </video>
<p class="card-text">
    But these results are susceptible to change in lab settings, e.g. different textures of the floor and smoothness of the tires, etc..</p>


<h2>Task 5: Go a Straight Line</h2>
    <p class="card-text">
    Initially, the car tended to drift towards its left side, so I added a calibration factor 1.2 which gave the left wheels more power so that the car can follow a fairly straight line. However, such static calibration method is susceptible to environment changes, so it is necessary to use PID control in future labs.</p>
    <img src="images/lab4/code.png" controls width="750">
    <p class="card-text">
    By applying the calibration stated above, the car can go a fairly straight line in the video</p>
    <video src="images/lab4/zhi.mp4" controls width="300" > </video>

<h2>Task 6: Open Loop Control</h2>
    <p class="card-text">
        I write up all the actions in functions to make the code more readable:</p>
    <img src="images/lab4/func.png" controls width="750">
   <p class="card-text">
    For the untethered open loop control, the car is programmed to move forth and back and make a clockwise turn repeatedly with the following codes:</p>
    <img src="images/lab4/do.png" controls width="750">
    <video src="images/lab4/last.mp4" controls width="300" > </video>
<h2>Additional 5160 level Task 1: AnalogWrite Frequency Discussion</h2>
    <p class="card-text">
    The Artemis board, by default, generates a PWM signal at 500 Hz. To produce a PWM signal with a significantly higher or lower frequency, it's necessary to alter the counter/timer configuration and utilize the repeated pulse mode. For instance, to create a PWM signal at approximately 3kHz with a 75% duty cycle, one would start by setting up the clock to output at the target frequency. To achieve the 75% duty cycle, the CMPR0 register is set to 75% of the maximum count value, causing the output to toggle each time the counter hits this value. Once the counter reaches its maximum and resets, the cycle starts anew.</p>
    <p class="card-text">
        The motor driver's datasheet indicates an acceptable input PWM frequency range from 0 Hz to 200 kHz, with a stipulation that input pulses should maintain a minimum width of 800 ns for reliable detection. With a base frequency of 500 Hz, there is a theoretical duty cycle range from nearly 0% to just under 100%. At higher PWM frequencies, the effective duty cycle range diminishes because of the shorter period of the PWM signal. Nonetheless, demonstrations in the provided videos show that the 500 Hz frequency is adequate, negating the necessity to increase the frequency for this application.</p>
<h2>Additional 5160 level Task 2: Lower Limit PWM Value in Motion</h2>
    <p class="card-text">
    As static friction is greater than kinetic friction, it takes higher voltage to start the car from still than to keep it moving while in motion. To explore the lower limit PWM value in motion, I set the initial speed as 60 to start the car, then deduct 2 from the value every 3 seconds to see which value stops the car.</p>
<video src="images/lab4/stop.mp4" controls width="300" > </video>
    <p class="card-text">
    As demonstrated in the video, the car stopped after 9 seconds from the time it started to move, which corresponded to PWM value of 54. So the lowest limit is 54 to keep the car running in motion, which is lower than the limit to start (60).</p>

</div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">close</button>
            </div>
        </div>
    </div>
</div>
                </div>









<!-- Content Row-->
            <div class="row gx-4 gx-lg-5">
                <div class="col-md-4 mb-5">
                    <div class="card h-100">
                        <div class="card-body">
                            <h2 class="card-title">Lab Five</h2>
                            <p class="card-text">Lab Five is about Linear PID control and Linear interpolation</p>
                        </div>
                        <button type="button" class="btn btn-primary btn-sm" data-bs-toggle="modal" data-bs-target="#labFiveModal">
        More Info
    </button>
                    </div>
                <div class="modal fade" id="labFiveModal" tabindex="-1" aria-labelledby="labFiveModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="labFiveModalLabel">Lab Five Information</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
<div class="modal-body" style="overflow-y: auto; max-height: 80vh;">


                    <h2>Prelab</h2>
    <p class="card-text">    
While observing our car's behavior is crucial for PID tuning, accessing key data from sensors and Artemis is essential. Hence, I developed a new string processing function, along with data storage and plotting capabilities.</p>
    <img src="images/lab5/pycode.png" controls width="750">
    <img src="images/lab5/pycode2.png" controls width="750">
    <p class="card-text">    
On Artemis, data comprising time, distance, and PWM is packaged and sent. By eliminating symbols and using "|" for separation, I've minimized the data transmission time, allowing for a shorter control period. This adjustment is crucial because we're working with a single core for both PID control and data transmission. The implementation of this strategy, alongside PID control, will be detailed in the subsequent section.</p>
    <img src="images/lab5/data.png" controls width="750">

    <h2>P/I/D Discussion </h2>
<p class="card-text"> 
    PID stands for Proportional-Integral-Derivative control, with the formula for correction being correction = Kperror + Kiintegral of error + Kd*derivative of error.</p>
    <p class="card-text">
        The proportional gain, Kp, addresses the current error (the discrepancy between the desired and actual values) proportionately. Increasing Kp intensifies the control response, though it may lead to overshoot or instability.</p>
    <p class="card-text">
        The integral gain, Ki, compensates for accumulated errors over time. It enhances control action for prolonged errors, but overly high values can introduce overshoot or oscillation due to the delay in counteracting accumulated errors.</p>
    <p class="card-text">
        The derivative gain, Kd, anticipates future errors by considering the error's rate of change. It serves as a dampener to minimize overshoot and slow down the response speed, but it may exacerbate noise in the system.</p>


    <h2>Range/Sampling Time Discussion</h2>
    <p class="card-text">
Initially, my PID loop included a delay to wait for the distance sensor data to be ready, using while (!distanceSensor1.checkForDataReady()) delay(1). This setup resulted in each cycle averaging 90-100 ms. To accelerate the loop times, I removed the code that waited for sensor readiness. Consequently, the revised PID loop now operates at 8-9 ms per cycle, with the majority of this time, approximately 7 ms, being attributed to reading from the Time-of-Flight (TOF) sensor.</p>
    <h2>PID Implementation</h2>
    <p class="card-text">
    The PID control was implemented using the code provided. It's important to highlight that the car requires a minimum PWM value to overcome friction  Therefore, any PWM value below these thresholds is practically ineffective. To address this, I incorporate these threshold values directly when configuring the GPIO. Additionally, I've imposed a limit of 30 on the PWM for the left side to simplify control of the car.</p>
      <p class="card-text">
The code is as below, together with BLE data-sending functions. I finally tuned my proportional parameter to 0.7 and my integral parameter to 0.02.</p>
    <img src="images/lab5/code.png" controls width="750">
<h2>Result</h2>
<p class="card-text">
    In the short-distance startup test, the car's response was as follows, and I have plotted the data accordingly. I believe the car performed well.</p>
    <video src="images/lab5/stop.mp4" controls width="300" > </video>
    <img src="images/lab5/plot.png" controls width="750">
    <h2>Wind-up protection for integrator (5000+ level)</h2>
    <p class="card-text">
Windup, a challenge with the integral term, leads to overshoot by allowing the integral component's accumulation to exceed the control signal's saturation limits. To combat this, I utilize two strategies: implementing bounds and adopting the Clegg Integrator. The Clegg Integrator resets the accumulated integral value whenever the error changes sign, effectively clearing any built-up error that could contribute to windup in the opposite direction.</p>
    

</div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">close</button>
            </div>
        </div>
    </div>
</div>
                </div>



<!-- Content Row-->
            <div class="row gx-4 gx-lg-5">
                <div class="col-md-4 mb-5">
                    <div class="card h-100">
                        <div class="card-body">
                            <h2 class="card-title">Lab Six</h2>
                            <p class="card-text">Lab six focus on developing PID control systems that enable robotic cars to autonomously fix their orientation.</p>
                        </div>
                        <button type="button" class="btn btn-primary btn-sm" data-bs-toggle="modal" data-bs-target="#labSixModal">
        More Info
    </button>
                    </div>
                <div class="modal fade" id="labSixModal" tabindex="-1" aria-labelledby="labSixModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="labSixModalLabel">Lab Six Information</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
<div class="modal-body" style="overflow-y: auto; max-height: 80vh;">


                    <h2>Prelab</h2>
<p class="card-text">
    The lab focuses on developing PID control systems that enable robotic cars to autonomously fix their orientation. The orientation measurements required for this operation are obtained via an IMU sensor integrated into the robot.</p>
<p class="card-text">
    Debugging data was send over bluetooth from the Artemis board to the computer, where a Python handler function is used to store the data in various arrays. Time, error (Angle to the set oriantation), PID value (sent seperately) and pwm were all logged.</p>
    <img src="images/lab6/send.png" controls width="750">
    <img src="images/lab6/pycode.png" controls width="750">
    <h2>P/I/D Discussion </h2>
<p class="card-text"> 
    PID stands for Proportional-Integral-Derivative control, with the formula for correction being correction = Kperror + Kiintegral of error + Kd*derivative of error.</p>
    <p class="card-text">
        The proportional gain, Kp, addresses the current error (the discrepancy between the desired and actual values) proportionately. Increasing Kp intensifies the control response, though it may lead to overshoot or instability.</p>
    <p class="card-text">
        The integral gain, Ki, compensates for accumulated errors over time. It enhances control action for prolonged errors, but overly high values can introduce overshoot or oscillation due to the delay in counteracting accumulated errors.</p>
    <p class="card-text">
        The derivative gain, Kd, anticipates future errors by considering the error's rate of change. It serves as a dampener to minimize overshoot and slow down the response speed, but it may exacerbate noise in the system.</p>
     <h2>Range/Sampling Time Discussion</h2>
    <p class="card-text">
Initially, my PID loop included a delay to wait for the distance sensor data to be ready, using while (!distanceSensor1.checkForDataReady()) delay(1). This setup resulted in each cycle averaging 90-100 ms. To accelerate the loop times, I removed the code that waited for sensor readiness. Consequently, the revised PID loop now operates at 8-9 ms per cycle, with the majority of this time, approximately 7 ms, being attributed to reading from the Time-of-Flight (TOF) sensor.</p>

    <h2>PID Implementation</h2>
    <p class="card-text"> The way I implement PID for setting oriantation is shown as follows.</p>
        <img src="images/lab6/code.png" controls width="750">
    <p class="card-text"> After testing, I set Kp = 8 , Ki = 1, Kd = 0.05</p>
    <h2>Result</h2>
<p class="card-text">
    In the test, the car's response was as follows, and I have plotted the data accordingly. I believe the car performed well.</p>
    <video src="images/lab6/sPIDO.mp4" controls width="300" > </video>
    <img src="images/lab6/plot.png" controls width="750">
    
    
<h2>Wind-up protection for integrator (5000+ level)</h2>
    <p class="card-text">
Windup presents a problem in the integral part of PID control, resulting in overshoot by permitting the integral term to build up beyond the saturation limits of the control signal. To mitigate this issue, I set limits on the integral term's accumulation.</p>





    
</div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">close</button>
            </div>
        </div>
    </div>
</div>
                </div>

                
                
    
        <!-- Footer-->
        <footer class="py-5 bg-dark">
            <div class="container px-4 px-lg-5"><p class="m-0 text-center text-white">Copyright &copy; my Website 2023</p></div>
        </footer>
        <!-- Bootstrap core JS-->
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"></script>
        <!-- Core theme JS-->
        <script src="js/scripts.js"></script>
    </body>
</html>
